#!/usr/bin/env python3
"""
Flask Web App for TurboNIW Email Sender
Provides UI for managing accounts, authentication, and sending emails.
"""

from flask import Flask, render_template, request, jsonify, redirect, url_for, session, flash
import json
import os
from pathlib import Path
from datetime import datetime, date, time as dt_time
import threading
import time
import random
import signal
import sys
from werkzeug.utils import secure_filename
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.cron import CronTrigger
import pytz

# Import existing email sender classes
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from send_emails_smtp import EmailSender
from send_emails_gmail_api import GmailAPISender

app = Flask(__name__)
app.secret_key = os.urandom(24)  # Change this in production!

# Paths
BASE_DIR = Path(__file__).parent.parent
CONFIG_FILE = BASE_DIR / 'config.json'
HISTORY_FILE = BASE_DIR / 'sent_history.json'
SECRETS_DIR = BASE_DIR / '.secrets'

# Global state - Industry standard: in-memory state for real-time UI updates
sending_active = False
sending_thread = None
sending_thread_id = None  # Track thread ID for persistence across page loads
sending_progress = {
    "sent": 0,              # Total sent today (updated in real-time via callback)
    "failed": 0,            # Total failed
    "total": 0,             # Total capacity (sum of enabled accounts' daily limits)
    "current_name": "",     # Current recipient being processed
    "current_email": "",    # Current recipient email
    "account_stats": {},    # Per-account stats: {account_id: {"sent": count, "limit": limit}}
    "date": None,           # Date this state is for (reset when date changes)
    "thread_id": None       # Thread ID for tracking across page loads
}
progress_lock = threading.Lock()  # Thread-safe updates


def graceful_shutdown(signum, frame):
    """Handle graceful shutdown on SIGINT/SIGTERM to clean up threads."""
    global sending_active, sending_thread, scheduler
    print("\n\nüõë Shutting down gracefully...")
    
    # Stop sending if active
    if sending_active:
        print("‚èπÔ∏è  Stopping email sending...")
        sending_active = False
        # Wait a bit for threads to finish (but not too long)
        if sending_thread and sending_thread.is_alive():
            sending_thread.join(timeout=2.0)
    
    # Shutdown scheduler
    if scheduler and scheduler.running:
        print("‚èπÔ∏è  Stopping scheduler...")
        scheduler.shutdown()
    
    print("‚úÖ Shutdown complete")
    sys.exit(0)


def load_config():
    """Load configuration from JSON."""
    if CONFIG_FILE.exists():
        with open(CONFIG_FILE, 'r') as f:
            return json.load(f)
    return {
        "accounts": [],
        "email": {"_note": "Subject lines are dynamically generated"},
        "sending": {
            "delay_min_seconds": 10,
            "delay_max_seconds": 60,
            "max_retries": 2,
            "max_parallel_accounts": 10
        },
        "paths": {"sent_history": "sent_history.json"},
        "test_whitelist": {"emails": []},
        "blacklist": {"emails": []}
    }


def save_config(config):
    """Save configuration to JSON."""
    with open(CONFIG_FILE, 'w') as f:
        json.dump(config, f, indent=2)


@app.route('/')
def dashboard():
    """Main dashboard."""
    config = load_config()
    history = load_history()
    today = str(date.today())
    
    # Calculate stats
    total_accounts = len(config.get('accounts', []))
    enabled_accounts = sum(1 for acc in config.get('accounts', []) if acc.get('enabled', True))
    
    # Today's stats
    daily_stats = history.get('daily_stats', {}).get(today, {})
    # Sum only account-specific values, exclude 'total' key to avoid double-counting
    total_sent_today = sum(v for k, v in daily_stats.items() if k != 'total')
    
    # Account breakdown
    account_stats = []
    for account in config.get('accounts', []):
        if account.get('enabled', True):
            account_id = account['id']
            sent_today = daily_stats.get(account_id, 0)
            daily_limit = account.get('daily_limit', 0)
            account_stats.append({
                'id': account_id,
                'email': account['email'],
                'method': account.get('auth_method', 'app_password'),
                'sent_today': sent_today,
                'daily_limit': daily_limit,
                'remaining': max(0, daily_limit - sent_today)
            })
    
    return render_template('dashboard.html',
                         total_accounts=total_accounts,
                         enabled_accounts=enabled_accounts,
                         total_sent_today=total_sent_today,
                         account_stats=account_stats,
                         sending_active=sending_active)


def load_history():
    """Load sent email history."""
    if HISTORY_FILE.exists():
        try:
            with open(HISTORY_FILE, 'r') as f:
                return json.load(f)
        except:
            pass
    return {"recipients": {}, "daily_stats": {}}


@app.route('/accounts')
def accounts():
    """Account management page."""
    config = load_config()
    return render_template('accounts.html', accounts=config.get('accounts', []))


@app.route('/api/accounts', methods=['GET'])
def get_accounts():
    """Get all accounts."""
    config = load_config()
    return jsonify(config.get('accounts', []))


@app.route('/api/accounts', methods=['POST'])
def add_account():
    """Add a new account."""
    # Check if this is a file upload (FormData) or JSON
    if request.content_type and 'multipart/form-data' in request.content_type:
        # Handle file upload
        account_id = request.form.get('id')
        email = request.form.get('email')
        name = request.form.get('name', 'Wen')
        auth_method = request.form.get('auth_method', 'app_password')
        daily_limit = int(request.form.get('daily_limit', 10))
        
        config = load_config()
        
        # Create new account
        account = {
            "id": account_id,
            "email": email,
            "name": name,
            "auth_method": auth_method,
            "daily_limit": daily_limit,
            "enabled": True
        }
        
        if auth_method == 'app_password':
            account['app_password_file'] = f".secrets/{account_id}_password.txt"
            # Create password file if provided
            password = request.form.get('password')
            if password:
                SECRETS_DIR.mkdir(exist_ok=True)
                password_file = SECRETS_DIR / f"{account_id}_password.txt"
                with open(password_file, 'w') as f:
                    f.write(password)
        elif auth_method == 'gmail_api':
            # Handle credentials file upload
            if 'credentials_file' not in request.files:
                return jsonify({"success": False, "error": "Credentials file is required for Gmail API"}), 400
            
            credentials_file = request.files['credentials_file']
            if credentials_file.filename == '':
                return jsonify({"success": False, "error": "No file selected"}), 400
            
            if not credentials_file.filename.endswith('.json'):
                return jsonify({"success": False, "error": "Credentials file must be a JSON file"}), 400
            
            # Save credentials file with standardized name
            SECRETS_DIR.mkdir(exist_ok=True)
            credentials_path = SECRETS_DIR / f"gmail_credentials_{account_id}.json"
            credentials_file.save(str(credentials_path))
            
            account['credentials_file'] = f".secrets/gmail_credentials_{account_id}.json"
        
        config['accounts'].append(account)
        save_config(config)
        
        return jsonify({"success": True, "account": account})
    else:
        # Handle JSON request (backward compatibility)
        data = request.json
        config = load_config()
        
        # Create new account
        account = {
            "id": data.get('id'),
            "email": data.get('email'),
            "name": data.get('name', 'Wen'),
            "auth_method": data.get('auth_method', 'app_password'),
            "daily_limit": int(data.get('daily_limit', 10)),
            "enabled": data.get('enabled', True)
        }
        
        if account['auth_method'] == 'app_password':
            account['app_password_file'] = f".secrets/{account['id']}_password.txt"
            # Create password file if provided
            if data.get('password'):
                SECRETS_DIR.mkdir(exist_ok=True)
                password_file = SECRETS_DIR / f"{account['id']}_password.txt"
                with open(password_file, 'w') as f:
                    f.write(data['password'])
        elif account['auth_method'] == 'gmail_api':
            account['credentials_file'] = f".secrets/gmail_credentials_{account['id']}.json"
            # Note: User needs to upload credentials file separately
        
        config['accounts'].append(account)
        save_config(config)
        
        return jsonify({"success": True, "account": account})


@app.route('/api/accounts/<account_id>', methods=['PUT'])
def update_account(account_id):
    """Update an account."""
    data = request.json
    config = load_config()
    
    for i, account in enumerate(config['accounts']):
        if account['id'] == account_id:
            # Update fields
            if 'email' in data:
                account['email'] = data['email']
            if 'name' in data:
                account['name'] = data['name']
            if 'daily_limit' in data:
                account['daily_limit'] = int(data['daily_limit'])
            if 'enabled' in data:
                account['enabled'] = data['enabled']
            if 'password' in data and account.get('auth_method') == 'app_password':
                # Update password file
                password_file = SECRETS_DIR / f"{account_id}_password.txt"
                SECRETS_DIR.mkdir(exist_ok=True)
                with open(password_file, 'w') as f:
                    f.write(data['password'])
            
            save_config(config)
            return jsonify({"success": True, "account": account})
    
    return jsonify({"success": False, "error": "Account not found"}), 404


@app.route('/api/accounts/<account_id>', methods=['DELETE'])
def delete_account(account_id):
    """Delete an account."""
    config = load_config()
    config['accounts'] = [acc for acc in config['accounts'] if acc['id'] != account_id]
    save_config(config)
    return jsonify({"success": True})


@app.route('/api/accounts/<account_id>/authenticate', methods=['POST'])
def authenticate_account(account_id):
    """Authenticate a Gmail API account."""
    import sys
    sys.stdout.flush()
    
    print(f"\n{'='*80}")
    print(f"üîê AUTHENTICATION REQUEST RECEIVED")
    print(f"{'='*80}")
    print(f"   Account ID: {account_id}")
    sys.stdout.flush()
    
    config = load_config()
    account = next((acc for acc in config['accounts'] if acc['id'] == account_id), None)
    
    if not account:
        print(f"‚ùå Account not found: {account_id}")
        sys.stdout.flush()
        return jsonify({"success": False, "error": "Account not found"}), 404
    
    account_email = account.get('email', 'Unknown')
    print(f"   Email: {account_email}")
    print(f"   Auth Method: {account.get('auth_method', 'Unknown')}")
    sys.stdout.flush()
    
    if account.get('auth_method') != 'gmail_api':
        print(f"‚ùå Only Gmail API accounts can be authenticated")
        sys.stdout.flush()
        return jsonify({"success": False, "error": "Only Gmail API accounts can be authenticated"}), 400
    
    # Import authentication function
    sys.path.append(str(BASE_DIR))
    from test_gmail_auth import authenticate_account as auth_func
    
    # Resolve credentials file path (handle both relative and absolute)
    cred_file_path = account['credentials_file']
    if not Path(cred_file_path).is_absolute():
        credentials_file = BASE_DIR / cred_file_path
    else:
        credentials_file = Path(cred_file_path)
    
    print(f"   Credentials File: {credentials_file}")
    sys.stdout.flush()
    
    if not credentials_file.exists():
        print(f"‚ùå Credentials file not found: {credentials_file}")
        sys.stdout.flush()
        return jsonify({"success": False, "error": f"Credentials file not found: {credentials_file}"}), 400
    
    print(f"\n{'='*80}")
    print(f"üåê STARTING AUTHENTICATION PROCESS")
    print(f"   Account: {account_id} ({account_email})")
    print(f"{'='*80}\n")
    sys.stdout.flush()
    
    try:
        # Change to BASE_DIR to ensure consistent working directory
        original_cwd = os.getcwd()
        os.chdir(str(BASE_DIR))
        
        try:
            # Run authentication (this will open browser)
            print(f"‚è≥ Calling authentication function...")
            sys.stdout.flush()
            success = auth_func(account_id, str(credentials_file.resolve()))
            if success:
                print(f"\n{'='*80}")
                print(f"‚úÖ AUTHENTICATION ENDPOINT: SUCCESS")
                print(f"   Account: {account_id} ({account_email})")
                print(f"{'='*80}\n")
                sys.stdout.flush()
                return jsonify({"success": True, "message": "Authentication successful"})
            else:
                print(f"\n{'='*80}")
                print(f"‚ùå AUTHENTICATION ENDPOINT: FAILED")
                print(f"   Account: {account_id} ({account_email})")
                print(f"{'='*80}\n")
                sys.stdout.flush()
                return jsonify({"success": False, "error": "Authentication failed"}), 400
        finally:
            os.chdir(original_cwd)
    except Exception as e:
        import traceback
        error_msg = str(e)
        print(f"Authentication error: {error_msg}")
        print(traceback.format_exc())
        return jsonify({"success": False, "error": error_msg}), 500


@app.route('/settings')
def settings():
    """Settings page."""
    config = load_config()
    return render_template('settings.html', config=config)


@app.route('/api/settings', methods=['PUT'])
def update_settings():
    """Update settings."""
    data = request.json
    config = load_config()
    
    if 'sending' in data:
        config['sending'].update(data['sending'])
    if 'test_whitelist' in data:
        config['test_whitelist'] = data['test_whitelist']
    if 'blacklist' in data:
        config['blacklist'] = data['blacklist']
    
    save_config(config)
    return jsonify({"success": True})


@app.route('/send')
def send_page():
    """Email sending page."""
    # Get default CSV path from config or use standard path
    default_csv = None
    config = load_config()
    
    # Try to find default CSV in common locations
    possible_paths = [
        BASE_DIR.parent / 'data' / 'arxiv' / 'round1' / 'arxiv_high_confidence_non_chinese_no_acl.csv',
        BASE_DIR.parent / 'data' / 'arxiv' / 'round1' / 'arxiv_high_confidence_non_chinese.csv',
        BASE_DIR.parent / 'data' / 'arxiv' / 'round1' / 'arxiv_high_confidence.csv',
    ]
    
    for path in possible_paths:
        if path.exists():
            default_csv = str(path.relative_to(BASE_DIR.parent))
            break
    
    return render_template('send.html', default_csv=default_csv)


@app.route('/api/send/load-default-csv', methods=['GET'])
def load_default_csv():
    """Load default CSV file."""
    import csv
    
    csv_path = request.args.get('path')
    if not csv_path:
        return jsonify({"success": False, "error": "No path provided"}), 400
    
    # Resolve path relative to project root
    full_path = BASE_DIR.parent / csv_path
    
    if not full_path.exists():
        return jsonify({"success": False, "error": f"File not found: {csv_path}"}), 404
    
    try:
        data = []
        with open(full_path, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            for row in reader:
                data.append(row)
        
        return jsonify({"success": True, "data": data, "count": len(data)})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


# Removed queue system - now uses process_csv() directly like command-line


@app.route('/api/send/start', methods=['POST'])
def start_sending():
    """Start sending emails - processes CSV and sends directly like command-line."""
    global sending_active, sending_thread, sending_thread_id
    import sys
    sys.stdout.flush()
    
    try:
        # Check thread state
        thread_alive = False
        if sending_thread:
            try:
                thread_alive = sending_thread.is_alive()
            except:
                thread_alive = False
                sending_thread = None
        
        # If thread is alive AND sending_active is True, reject (actually sending)
        if thread_alive and sending_active:
            print(f"‚ö†Ô∏è  Cannot start: Sending already in progress (thread_id={sending_thread.ident if sending_thread else 'None'})")
            sys.stdout.flush()
            return jsonify({"success": False, "error": "Sending already in progress"}), 400
        
        # If thread is alive but sending_active is False, it's stopping - wait for it to finish
        if thread_alive and not sending_active:
            print(f"‚è≥ Thread is finishing (stop was requested), waiting up to 5 seconds...")
            sys.stdout.flush()
            if sending_thread:
                sending_thread.join(timeout=5.0)
                # Check if still alive after wait
                try:
                    if sending_thread.is_alive():
                        print(f"‚ö†Ô∏è  Thread still alive after wait, clearing reference to allow new start")
                        sys.stdout.flush()
                        sending_thread = None
                        sending_thread_id = None
                        with progress_lock:
                            sending_progress["thread_id"] = None
                    else:
                        print(f"‚úì Thread finished successfully")
                        sys.stdout.flush()
                        sending_thread = None
                        sending_thread_id = None
                        with progress_lock:
                            sending_progress["thread_id"] = None
                except:
                    sending_thread = None
                    sending_thread_id = None
        
        # Clean up dead thread reference if any
        if sending_thread and not thread_alive:
            sending_thread = None
            sending_thread_id = None
            sending_active = False
            with progress_lock:
                sending_progress["thread_id"] = None
        
        # Get parameters
        data = request.json or {}
        csv_path = data.get('csv_path')
        max_emails = int(data.get('max_emails', 0))
        
        print(f"üì• Start request: csv_path={csv_path}, max_emails={max_emails}")
        
        # If no CSV path provided, use default
        if not csv_path:
            # Try to find default CSV - check multiple possible locations
            possible_paths = [
                # Round 2 (most recent)
                BASE_DIR.parent / 'data' / 'arxiv' / 'round2' / 'arxiv_high_confidence_non_chinese_no_acl_no_prior_rounds.csv',
                BASE_DIR.parent / 'data' / 'arxiv' / 'round2' / 'arxiv_high_confidence_non_chinese_no_acl.csv',
                BASE_DIR.parent / 'data' / 'arxiv' / 'round2' / 'arxiv_high_confidence_non_chinese.csv',
                # Round 1
                BASE_DIR.parent / 'data' / 'arxiv' / 'round1' / 'arxiv_high_confidence_non_chinese_no_acl.csv',
                BASE_DIR.parent / 'data' / 'arxiv' / 'round1' / 'arxiv_high_confidence_non_chinese.csv',
                # Legacy location
                BASE_DIR.parent / 'data' / 'arxiv' / 'arxiv_high_confidence_non_chinese_no_acl.csv',
            ]
            for path in possible_paths:
                if path.exists():
                    csv_path = str(path.relative_to(BASE_DIR.parent))
                    print(f"üìÅ Using default CSV: {csv_path}")
                    break
        
        if not csv_path:
            error_msg = "No CSV file specified and no default file found. Please upload a CSV file or ensure a default file exists."
            print(f"‚ùå {error_msg}")
            return jsonify({"success": False, "error": error_msg}), 400
        
        # Clear current recipient info - progress (sent/total) is always calculated from source of truth
        sending_progress["current_name"] = ""
        sending_progress["current_email"] = ""
        sending_progress["failed"] = 0
        
        sending_active = True
        sending_thread = threading.Thread(target=send_emails_worker_direct, args=(csv_path, max_emails), daemon=True)
        sending_thread.start()
        
        # Store thread ID in progress for persistence
        sending_thread_id = sending_thread.ident
        with progress_lock:
            sending_progress["thread_id"] = sending_thread_id
        
        print(f"‚úÖ Sending started: thread_id={sending_thread.ident}, csv_path={csv_path}")
        import sys
        sys.stdout.flush()
        return jsonify({"success": True, "message": "Sending started"})
    except Exception as e:
        import traceback
        error_msg = f"Error starting send: {str(e)}"
        print(f"‚ùå {error_msg}")
        print(traceback.format_exc())
        return jsonify({"success": False, "error": error_msg}), 500


@app.route('/api/send/stop', methods=['POST'])
def stop_sending():
    """Stop sending emails."""
    global sending_active, sending_progress, sending_thread
    import sys
    
    print(f"\n{'='*60}")
    print(f"‚èπÔ∏è  STOP REQUESTED")
    if sending_thread:
        print(f"   Thread ID: {sending_thread.ident}")
        print(f"   Thread Alive: {sending_thread.is_alive()}")
    print(f"{'='*60}\n")
    sys.stdout.flush()
    
    # Set flag to False - worker threads check this and will stop
    sending_active = False
    
    # Clear current recipient info
    with progress_lock:
        sending_progress["current_name"] = ""
        sending_progress["current_email"] = ""
    
    print(f"‚úì Stop flag set. Worker threads will stop after current email.")
    sys.stdout.flush()
    
    return jsonify({"success": True})


@app.route('/api/send/status', methods=['GET'])
def send_status():
    """Get sending status and progress - Industry standard: read from in-memory state."""
    global sending_thread, sending_active, sending_thread_id
    
    # Check thread state - use both object reference and thread ID for robustness
    thread_alive = False
    stored_thread_id = sending_progress.get("thread_id")
    
    # Method 1: Check thread object if it exists
    if sending_thread:
        try:
            thread_alive = sending_thread.is_alive()
            # Update thread ID if thread is alive
            if thread_alive:
                sending_thread_id = sending_thread.ident
                with progress_lock:
                    sending_progress["thread_id"] = sending_thread_id
        except:
            # Thread object invalid - clean up
            thread_alive = False
            sending_thread = None
            sending_thread_id = None
            sending_active = False
            with progress_lock:
                sending_progress["thread_id"] = None
    
    # Method 2: If thread object is None but we have a thread ID, check if thread still exists
    # (This helps with persistence across page loads)
    if not thread_alive and stored_thread_id:
        # Try to find the thread by ID
        import threading
        for thread in threading.enumerate():
            if thread.ident == stored_thread_id and thread.is_alive():
                # Found the thread! Restore reference
                sending_thread = thread
                thread_alive = True
                break
        else:
            # Thread not found - it's dead
            with progress_lock:
                sending_progress["thread_id"] = None
            sending_thread_id = None
            sending_active = False
    
    # Clean up if thread is dead
    if sending_thread and not thread_alive:
        sending_thread = None
        sending_thread_id = None
        sending_active = False
        with progress_lock:
            sending_progress["thread_id"] = None
    
    # Status: active if thread is alive
    is_active = thread_alive
    is_stopping = thread_alive and not sending_active  # Thread alive but stop was requested
    
    # CRITICAL: Check if it's a new day - reset progress if date changed
    today = str(date.today())
    with progress_lock:
        progress_date = sending_progress.get("date")
        
        # If date changed, reset progress for new day
        if progress_date != today:
            sending_progress["sent"] = 0
            sending_progress["failed"] = 0
            sending_progress["account_stats"] = {}
            sending_progress["date"] = today
            # Don't reset total - will be recalculated below
        
        sent_count = sending_progress.get("sent", 0)
        total_limit = sending_progress.get("total", 0)
        
        # Always recalculate total from current config (accounts/limits may have changed)
        # This ensures we show today's capacity, not yesterday's
        try:
            config = load_config()
            new_total = 0
            for account in config.get('accounts', []):
                if account.get('enabled', True):
                    if account.get('auth_method') in ['gmail_api', 'app_password']:
                        new_total += account.get('daily_limit', 0)
            
            # Update total if it changed (user may have updated limits)
            if new_total != total_limit:
                sending_progress["total"] = new_total
                total_limit = new_total
        except:
            pass
        
        # If not active, sync sent count from history file (source of truth)
        # This ensures we show accurate count even after stopping or thread finishing
        if not is_active:
            try:
                history = load_history()
                if today in history.get('daily_stats', {}):
                    daily_stats = history['daily_stats'][today]
                    actual_sent = sum(
                        count for key, count in daily_stats.items() 
                        if key != 'total'
                    )
                    # Update progress with actual sent count from history
                    if actual_sent != sent_count:
                        sending_progress["sent"] = actual_sent
                        sent_count = actual_sent
            except:
                pass
    
    return jsonify({
        "active": is_active,
        "stopping": is_stopping,  # True when stop requested but thread still cleaning up
        "progress": {
            "sent": sent_count,
            "total": total_limit,
            "failed": sending_progress.get("failed", 0),
            "current_name": sending_progress.get("current_name", ""),
            "current_email": sending_progress.get("current_email", "")
        }
    })


def on_email_sent_callback(account_id, account_email, account_limit):
    """Callback function called by sender classes when an email is sent.
    Industry standard: Update in-memory state immediately for real-time UI updates."""
    global sending_progress
    with progress_lock:
        # Initialize account stats if needed
        if "account_stats" not in sending_progress:
            sending_progress["account_stats"] = {}
        if account_id not in sending_progress["account_stats"]:
            sending_progress["account_stats"][account_id] = {"sent": 0, "limit": account_limit}
        
        # Increment sent count for this account
        sending_progress["account_stats"][account_id]["sent"] += 1
        
        # Update total sent (sum across all accounts)
        sending_progress["sent"] = sum(
            stats["sent"] for stats in sending_progress["account_stats"].values()
        )


def send_emails_worker_direct(csv_path, max_emails=0):
    """Background worker that processes CSV and sends directly (exactly like command-line)."""
    global sending_active, sending_progress, sending_thread
    
    # Store thread reference for status checking
    import threading
    current_thread = threading.current_thread()
    print(f"üîµ Worker thread started: thread_id={current_thread.ident}, name={current_thread.name}")
    
    # Industry standard: Initialize progress state at start
    # 1. Load initial sent count from history file (for resume after restart)
    # 2. Calculate total capacity from config
    # 3. Initialize per-account stats
    today = str(date.today())
    with progress_lock:
        # Load initial state from history file
        initial_sent = 0
        account_stats = {}
        try:
            history = load_history()
            if today in history.get('daily_stats', {}):
                daily_stats = history['daily_stats'][today]
                for account_id, count in daily_stats.items():
                    if account_id != 'total':
                        account_stats[account_id] = {"sent": count, "limit": 0}
                        initial_sent += count
        except:
            pass
        
        # Calculate total capacity and initialize account stats
        total_capacity = 0
        try:
            config = load_config()
            for account in config.get('accounts', []):
                if account.get('enabled', True):
                    if account.get('auth_method') in ['gmail_api', 'app_password']:
                        account_id = account['id']
                        account_limit = account.get('daily_limit', 0)
                        total_capacity += account_limit
                        
                        # Initialize or update account stats
                        if account_id not in account_stats:
                            account_stats[account_id] = {"sent": 0, "limit": account_limit}
                        else:
                            account_stats[account_id]["limit"] = account_limit
        except:
            pass
        
        # Set initialized state
        sending_progress["sent"] = initial_sent
        sending_progress["total"] = total_capacity
        sending_progress["account_stats"] = account_stats
        sending_progress["current_name"] = ""
        sending_progress["current_email"] = ""
        sending_progress["failed"] = 0
        sending_progress["date"] = today  # Track which date this state is for
    
    try:
        # Change to BASE_DIR to ensure relative paths work correctly
        original_cwd = os.getcwd()
        os.chdir(str(BASE_DIR))
        
        try:
            # CRITICAL FIX: Use BOTH Gmail API and SMTP accounts if both are available
            config = load_config()
            has_gmail_api = any(acc.get('auth_method') == 'gmail_api' and acc.get('enabled', True) 
                               for acc in config.get('accounts', []))
            has_smtp = any(acc.get('auth_method') == 'app_password' and acc.get('enabled', True) 
                          for acc in config.get('accounts', []))
            
            # Initialize both senders if both account types are available
            gmail_sender = None
            smtp_sender = None
            
            if has_gmail_api:
                try:
                    print(f"üìß Initializing Gmail API sender...")
                    gmail_sender = GmailAPISender(str(CONFIG_FILE))
                    print(f"‚úì Gmail API sender initialized")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Gmail API initialization failed: {e}")
                    print(f"   Will continue with SMTP only if available")
            
            if has_smtp:
                try:
                    print(f"üìß Initializing SMTP sender...")
                    smtp_sender = EmailSender(str(CONFIG_FILE))
                    print(f"‚úì SMTP sender initialized")
                except Exception as e:
                    print(f"‚ö†Ô∏è  SMTP initialization failed: {e}")
                    print(f"   Will continue with Gmail API only if available")
            
            # Must have at least one sender
            if not gmail_sender and not smtp_sender:
                raise Exception("‚ùå No valid accounts available (both Gmail API and SMTP failed)")
            
            # Log enabled accounts
            enabled_accounts = [acc for acc in config.get('accounts', []) 
                              if acc.get('enabled', True) and acc.get('auth_method') in ['gmail_api', 'app_password']]
            print(f"\nüìã Enabled accounts ({len(enabled_accounts)}):")
            for acc in enabled_accounts:
                print(f"   ‚Ä¢ {acc['id']}: {acc.get('email', 'Unknown')} (limit: {acc.get('daily_limit', 0)}/day)")
            
            # Process CSV directly (same as command-line - no queue needed!)
            full_path = BASE_DIR.parent / csv_path
            if not full_path.exists():
                raise Exception(f"‚ùå CSV file not found: {csv_path}")
            
            # Calculate total daily limit for logging (status endpoint will calculate for UI)
            total_daily_limit = 0
            for account in config.get('accounts', []):
                if account.get('enabled', True):
                    if account.get('auth_method') in ['gmail_api', 'app_password']:
                        total_daily_limit += account.get('daily_limit', 0)
            
            # Count total recipients in CSV (for reference)
            import csv as csv_module
            with open(full_path, 'r', encoding='utf-8') as f:
                reader = csv_module.DictReader(f)
                total_recipients = sum(1 for _ in reader)
            
            print(f"üìä Total daily limit: {total_daily_limit}")
            print(f"üìä CSV recipients: {total_recipients}")
            print(f"üìä Max emails: {max_emails if max_emails > 0 else 'No limit'}")
            
            print(f"üöÄ Starting email sending (same as command-line)...")
            print(f"üìÅ CSV: {csv_path}")
            
            # Add stop check function
            def should_stop():
                return not sending_active
            
            # Process with Gmail API sender if available
            gmail_thread = None
            if gmail_sender:
                if hasattr(gmail_sender, 'set_stop_check'):
                    gmail_sender.set_stop_check(should_stop)
                if hasattr(gmail_sender, 'set_progress_callback'):
                    gmail_sender.set_progress_callback(on_email_sent_callback)
                print(f"üöÄ Starting Gmail API sending...")
                import sys
                sys.stdout.flush()
                # Process in a separate thread so we can also use SMTP
                import threading
                gmail_thread = threading.Thread(
                    target=gmail_sender.process_csv,
                    args=(str(full_path),),
                    kwargs={'test_mode': False, 'max_emails': max_emails if max_emails > 0 else None},
                    daemon=True
                )
                gmail_thread.start()
            
            # Process with SMTP sender if available (in parallel with Gmail API)
            smtp_thread = None
            if smtp_sender:
                if hasattr(smtp_sender, 'set_stop_check'):
                    smtp_sender.set_stop_check(should_stop)
                if hasattr(smtp_sender, 'set_progress_callback'):
                    smtp_sender.set_progress_callback(on_email_sent_callback)
                print(f"üöÄ Starting SMTP sending...")
                import sys
                sys.stdout.flush()
                # Process in a separate thread so it runs in parallel with Gmail API
                import threading
                smtp_thread = threading.Thread(
                    target=smtp_sender.process_csv,
                    args=(str(full_path),),
                    kwargs={'test_mode': False, 'max_emails': max_emails if max_emails > 0 else None},
                    daemon=True
                )
                smtp_thread.start()
            
            # Wait for both threads to complete
            if gmail_thread and smtp_thread:
                print(f"‚è≥ Waiting for both Gmail API and SMTP threads to complete...")
                import sys
                sys.stdout.flush()
                gmail_thread.join()
                smtp_thread.join()
            elif gmail_thread:
                gmail_thread.join()
            elif smtp_thread:
                smtp_thread.join()
            
            print(f"‚úÖ Email sending completed")
        except Exception as e:
            # Re-raise to be caught by outer handler
            raise
        finally:
            # Restore original working directory
            os.chdir(original_cwd)
        
    except Exception as e:
        import traceback
        error_msg = f"‚ùå Error in send_emails_worker_direct: {e}"
        print(f"\n{error_msg}")
        print(traceback.format_exc())
        sending_progress["current_name"] = f"Error: {str(e)[:50]}"
        # The error will be visible in the terminal/logs
    finally:
        # Ensure state is cleaned up when thread finishes
        import threading
        current_thread_id = threading.current_thread().ident
        print(f"\n{'='*60}")
        print(f"üî¥ WORKER THREAD FINISHING")
        print(f"   Thread ID: {current_thread_id}")
        print(f"{'='*60}\n")
        import sys
        sys.stdout.flush()
        
        sending_active = False
        with progress_lock:
            sending_progress["current_name"] = ""
            sending_progress["current_email"] = ""
            # Clear thread ID when thread finishes
            if sending_progress.get("thread_id") == current_thread_id:
                sending_progress["thread_id"] = None
        
        # Clear global thread reference if this is the active thread
        global sending_thread, sending_thread_id
        if sending_thread and sending_thread.ident == current_thread_id:
            sending_thread = None
            sending_thread_id = None
        
        print(f"‚úì Thread cleanup complete")
        sys.stdout.flush()
        # Don't reset total - status endpoint always calculates it fresh from config


@app.route('/stats')
def stats():
    """Statistics page."""
    history = load_history()
    config = load_config()
    
    # Calculate various stats
    total_recipients = len(history.get('recipients', {}))
    total_emails_sent = sum(recipient.get('send_count', 0) for recipient in history.get('recipients', {}).values())
    
    # Daily stats
    daily_stats = history.get('daily_stats', {})
    dates = sorted(daily_stats.keys(), reverse=True)[:30]  # Last 30 days
    
    return render_template('stats.html',
                         total_recipients=total_recipients,
                         total_emails_sent=total_emails_sent,
                         daily_stats=daily_stats,
                         dates=dates)


@app.route('/history')
def history():
    """Email history search page."""
    return render_template('history.html')


@app.route('/api/history/search', methods=['POST'])
def search_history():
    """Search email history by email address."""
    data = request.json or {}
    email = data.get('email', '').strip().lower()
    
    if not email:
        return jsonify({"success": False, "error": "Email address is required"}), 400
    
    try:
        history = load_history()
        recipients = history.get('recipients', {})
        
        # Search for exact match (case-insensitive)
        if email in recipients:
            recipient_data = recipients[email]
            return jsonify({
                "success": True,
                "found": True,
                "data": recipient_data
            })
        else:
            return jsonify({
                "success": True,
                "found": False,
                "message": f"No history found for {email}"
            })
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


def auto_send_emails():
    """Auto-send emails based on configured schedule and per-account random targets."""
    global sending_active
    
    # Don't run if manual sending is active
    if sending_active:
        print("‚è∏Ô∏è  Auto-send skipped: Manual sending in progress")
        return
    
    try:
        config = load_config()
        auto_send_config = config.get('auto_send', {})
        
        if not auto_send_config.get('enabled', False):
            print("‚è∏Ô∏è  Auto-send is disabled")
            return
        
        min_emails = auto_send_config.get('min_emails_per_account', 50)
        max_emails = auto_send_config.get('max_emails_per_account', 150)
        
        print(f"\n{'='*80}")
        print(f"ü§ñ AUTO-SEND TRIGGERED")
        print(f"{'='*80}")
        print(f"Time: {datetime.now()}")
        print(f"Range per account: {min_emails} - {max_emails} emails")
        print(f"{'='*80}\n")
        
        # Get default CSV
        csv_path = None
        possible_paths = [
            BASE_DIR.parent / 'data' / 'arxiv' / 'round1' / 'arxiv_high_confidence_non_chinese_no_acl.csv',
            BASE_DIR.parent / 'data' / 'arxiv' / 'round1' / 'arxiv_high_confidence_non_chinese.csv',
        ]
        for path in possible_paths:
            if path.exists():
                csv_path = str(path.relative_to(BASE_DIR.parent))
                break
        
        if not csv_path:
            print("‚ùå Auto-send failed: No default CSV file found")
            return
        
        # Load history to check daily limits
        history = load_history()
        today = str(date.today())
        daily_stats = history.get('daily_stats', {}).get(today, {})
        
        # Calculate targets for each enabled account
        account_targets = {}
        total_target = 0
        
        for account in config.get('accounts', []):
            if not account.get('enabled', True):
                continue
            if account.get('auth_method') not in ['gmail_api', 'app_password']:
                continue
            
            account_id = account['id']
            daily_limit = account.get('daily_limit', 0)
            sent_today = daily_stats.get(account_id, 0)
            remaining = max(0, daily_limit - sent_today)
            
            if remaining > 0:
                # Cap the range at the daily limit to ensure we never exceed it
                # If range is 50-300 but daily limit is 200, we use 50-200
                effective_min = min(min_emails, daily_limit)
                effective_max = min(max_emails, daily_limit)
                # Further cap at remaining (in case manual sends already happened)
                effective_max = min(effective_max, remaining)
                
                if effective_min > effective_max:
                    # If min exceeds the cap, skip this account
                    print(f"  [{account_id}] ‚è≠Ô∏è  Skipped (min {min_emails} exceeds remaining limit {remaining})")
                    continue
                
                # Randomly select target within effective range
                target = random.randint(effective_min, effective_max)
                account_targets[account_id] = {
                    'account': account,
                    'target': target,
                    'remaining': remaining,
                    'daily_limit': daily_limit,
                    'sent_today': sent_today
                }
                total_target += target
                print(f"  [{account_id}] Target: {target} emails (range: {effective_min}-{effective_max}, daily limit: {daily_limit}, already sent: {sent_today}, remaining: {remaining})")
        
        if not account_targets:
            print("‚è∏Ô∏è  No accounts available for auto-send (all at daily limit)")
            return
        
        print(f"\nüìä Total target: {total_target} emails across {len(account_targets)} accounts\n")
        
        # Change to BASE_DIR to ensure relative paths work correctly
        original_cwd = os.getcwd()
        os.chdir(str(BASE_DIR))
        
        try:
            # Determine which sender to use based on available accounts
            # Prefer Gmail API if available, otherwise use SMTP
            config = load_config()
            has_gmail_api = any(acc.get('auth_method') == 'gmail_api' and acc.get('enabled', True) 
                               for acc in config.get('accounts', []))
            has_smtp = any(acc.get('auth_method') == 'app_password' and acc.get('enabled', True) 
                          for acc in config.get('accounts', []))
            
            # Use the same logic as manual send
            sender = None
            if has_gmail_api:
                try:
                    sender = GmailAPISender(str(CONFIG_FILE))
                except Exception as e:
                    print(f"‚ö†Ô∏è  Gmail API initialization failed: {e}")
                    if has_smtp:
                        print("   Falling back to SMTP...")
                        sender = EmailSender(str(CONFIG_FILE))
                    else:
                        raise Exception("No valid accounts available")
            elif has_smtp:
                sender = EmailSender(str(CONFIG_FILE))
            else:
                raise Exception("‚ùå No enabled accounts found")
            
            # Set account targets for auto-send (this tells each account when to stop)
            sender.account_targets = {acc_id: info['target'] for acc_id, info in account_targets.items()}
            
            # Set progress callback
            if hasattr(sender, 'set_progress_callback'):
                sender.set_progress_callback(on_email_sent_callback)
            
            # Process CSV directly (same as manual send - uses same logic!)
            full_path = BASE_DIR.parent / csv_path
            if not full_path.exists():
                raise Exception(f"‚ùå CSV file not found: {csv_path}")
            
            print(f"üöÄ Starting auto-send (same logic as manual send)...")
            print(f"üìÅ CSV: {csv_path}")
            
            # Use the same process_csv method as manual send
            # The account_worker will check account_targets and stop when target is reached
            sender.process_csv(str(full_path), test_mode=False, max_emails=None)
            
            print(f"\n‚úÖ Auto-send completed")
            
        except Exception as e:
            import traceback
            print(f"\n‚ùå Auto-send error: {e}")
            print(traceback.format_exc())
        finally:
            os.chdir(original_cwd)
        
    except Exception as e:
        import traceback
        print(f"\n‚ùå Auto-send error: {e}")
        print(traceback.format_exc())
    finally:
        sending_active = False


@app.route('/auto-send')
def auto_send_page():
    """Auto-send settings page."""
    config = load_config()
    auto_send = config.get('auto_send', {})
    return render_template('auto_send.html', auto_send=auto_send)


@app.route('/api/auto-send/settings', methods=['GET'])
def get_auto_send_settings():
    """Get auto-send settings."""
    config = load_config()
    auto_send = config.get('auto_send', {
        'enabled': False,
        'min_emails_per_account': 50,
        'max_emails_per_account': 150,
        'schedule_time': '10:00',
        'timezone': 'America/New_York'
    })
    return jsonify({"success": True, "settings": auto_send})


@app.route('/api/auto-send/settings', methods=['PUT'])
def update_auto_send_settings():
    """Update auto-send settings."""
    data = request.json or {}
    
    try:
        config = load_config()
        
        # Update auto_send section
        if 'auto_send' not in config:
            config['auto_send'] = {}
        
        config['auto_send']['enabled'] = data.get('enabled', False)
        config['auto_send']['min_emails_per_account'] = int(data.get('min_emails_per_account', 50))
        config['auto_send']['max_emails_per_account'] = int(data.get('max_emails_per_account', 150))
        config['auto_send']['schedule_time'] = data.get('schedule_time', '10:00')
        config['auto_send']['timezone'] = data.get('timezone', 'America/New_York')
        
        # Validate range
        if config['auto_send']['min_emails_per_account'] > config['auto_send']['max_emails_per_account']:
            return jsonify({"success": False, "error": "Min emails must be <= max emails"}), 400
        
        save_config(config)
        
        # Restart scheduler with new settings
        restart_scheduler()
        
        return jsonify({"success": True, "message": "Auto-send settings updated"})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


def start_scheduler():
    """Start the background scheduler for auto-send."""
    global scheduler
    
    config = load_config()
    auto_send = config.get('auto_send', {})
    
    if not auto_send.get('enabled', False):
        print("‚è∏Ô∏è  Auto-send scheduler not started (disabled)")
        return
    
    # Parse schedule time
    schedule_time = auto_send.get('schedule_time', '10:00')
    timezone_str = auto_send.get('timezone', 'America/New_York')
    
    try:
        hour, minute = map(int, schedule_time.split(':'))
    except:
        hour, minute = 10, 0  # Default to 10:00
    
    tz = pytz.timezone(timezone_str)
    
    scheduler = BackgroundScheduler(timezone=tz)
    scheduler.add_job(
        func=auto_send_emails,
        trigger=CronTrigger(hour=hour, minute=minute),
        id='auto_send_daily',
        name='Daily auto-send at 10 AM ET',
        replace_existing=True
    )
    scheduler.start()
    print(f"‚úÖ Auto-send scheduler started: Daily at {schedule_time} {timezone_str}")


def restart_scheduler():
    """Restart scheduler with updated settings."""
    global scheduler
    if scheduler and scheduler.running:
        scheduler.shutdown()
    start_scheduler()


# Initialize scheduler
scheduler = None


if __name__ == '__main__':
    # Force unbuffered output for real-time logging
    import sys
    sys.stdout = sys.__stdout__  # Ensure stdout is not buffered
    import os
    os.environ['PYTHONUNBUFFERED'] = '1'
    # Register signal handlers for graceful shutdown
    signal.signal(signal.SIGINT, graceful_shutdown)
    signal.signal(signal.SIGTERM, graceful_shutdown)
    
    # Ensure secrets directory exists
    SECRETS_DIR.mkdir(exist_ok=True)
    
    # Start auto-send scheduler if enabled
    start_scheduler()
    
    # Use port 5001 (5000 is often used by macOS AirPlay Receiver)
    port = int(os.environ.get('PORT', 5001))
    
    print(f"\nüöÄ Starting TurboNIW Email Sender Web App...")
    print(f"üìß Open your browser at: http://localhost:{port}")
    print(f"üåê Or access from network: http://0.0.0.0:{port}")
    print(f"\nPress Ctrl+C to stop the server\n")
    
    # Run app
    try:
        app.run(debug=True, host='0.0.0.0', port=port, use_reloader=False)  # Disable reloader to prevent scheduler duplication
    except KeyboardInterrupt:
        graceful_shutdown(None, None)
    finally:
        # Shutdown scheduler on exit
        if scheduler and scheduler.running:
            scheduler.shutdown()

